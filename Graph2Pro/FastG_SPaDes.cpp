//Package: tag
//Program Name: FastG_SPaDes (for loading input file in FastG format generated by MetaSPaDes)
//Latest modification on April 22th, 2016
//Yuzhen Ye <yye@indiana.edu> and Haixu Tang <hatang@indiana.edu>
//Affiliation: School of Informatics and Computing, Indiana University, Bloomington
#include "FastG_SPaDes.h"
#include "soap.h"
#include "smallapp.h"
#include "seq.h"
#include <algorithm>
#include <stdlib.h>

int FastGSPaDes::countedge(char *edgeseqfile)
{
	int	num_edge = 0;
	std::string s;
	std::ifstream fp_edge(edgeseqfile);

        if(!fp_edge) {
                cout<<"cannot open file "<<edgeseqfile<<endl;
                exit(0);
        }
	while(!fp_edge.eof()) {
		std::getline(fp_edge, s);
		const char* str = s.c_str();
		if(str[0] == '>')	{
			num_edge ++;
		}
	}
	fp_edge.close();
	return(num_edge);
}

int FastGSPaDes::inputedgenames(char *edgeseqfile, char **alledgename)
{
	int	num_edge = 0;
	std::string s;
	std::ifstream fp_edge(edgeseqfile);

        if(!fp_edge) {
                cout<<"cannot open file "<<edgeseqfile<<endl;
                exit(0);
        }
	while(!fp_edge.eof()) {
		std::getline(fp_edge, s);
		const char* str = s.c_str();
		if(str[0] == '>')	{
			replace(s.begin(), s.end(), ':', ' ');
			alledgename[num_edge] = (char *) smallapp::ckalloc(s.length() * sizeof(char));
			sscanf(&str[1], "%s", alledgename[num_edge]);
			int length = strlen(alledgename[num_edge]);
			if(alledgename[num_edge][length - 1] == ';')	{
				alledgename[num_edge][length - 1] = '\0';
			}
			num_edge ++;
		}
	}
	fp_edge.close();
	qsort(alledgename, num_edge, sizeof(char *), FastGSPaDes::strcmpr);
	return(num_edge);
}

int FastGSPaDes::strcmpr(const void *a, const void *b)
{
    const char **ia = (const char **)a;
    const char **ib = (const char **)b;
    return strcmp(*ia, *ib);
}

int FastGSPaDes::locaterevedge(char **alledgename, char *edgename, int num_edge)
{
	int i, l;
	char	edgenamtmp[501];

	strcpy(edgenamtmp, edgename);
	l = strlen(edgename);
	if(edgename[l - 1] != '\'')	{	// convert edgename to its reverse
		edgenamtmp[l ++] = '\'';
		edgenamtmp[l] = '\0';
	} else	{
		edgenamtmp[l - 1] = '\0';
	}

	int begin = 0;
	int end = num_edge - 1;
	while(begin <= end)	{	// binary search
		int mid = (begin + end) / 2;
		if(!strcmp(alledgename[mid], edgenamtmp))	{
			return(mid); // find edge 
		} else if(strcmp(alledgename[mid], edgenamtmp) < 0)	{
			begin = mid + 1;
		} else	{
			end = mid - 1;
		}
	}
	printf("Palindrom edge: %s\n", edgename);
	return(-1);
}

int FastGSPaDes::locateedge(char **alledgename, char *edgename, int num_edge)
{
	int i, l;
	int begin = 0;
	int end = num_edge - 1;
	while(begin <= end)	{	// binary search
		int mid = (begin + end) / 2;
		if(!strcmp(alledgename[mid], edgename))	{
			return(mid); // find edge 
		} else if(strcmp(alledgename[mid], edgename) < 0)	{
			begin = mid + 1;
		} else	{
			end = mid - 1;
		}
	}
	printf("Edge not found: %s\n", edgename);
	exit(-1);
}

int FastGSPaDes::readedge(char *edgeseqfile, EDGE *edge, VERTEX *vertex, int *edgeindex, int num_edge, int kmersize, char **alledgename)
{
	int	i, j, k, l, n, m;
	int	num_vertex;
	uint256_t	c1, c2;
	char	*seq;
	int	seqlen, max_len;
	int	len, strand;
	char	node1[100], node2[100];
	char	tmpstr[1000001], edgename[501];
	char	*tmpseq;
	std::string s;

	cout<<"edgeseqfile "<<edgeseqfile<<endl;
	edgename[0] = '\0';
	max_len = 0;

	tmpseq = (char *) smallapp::ckalloc(MAX_CON_LEN * sizeof(char));
	seqlen = 0;

	std::ifstream fp_edge(edgeseqfile);
	if(!fp_edge) {
		cout<<"cannot open file "<<edgeseqfile<<endl;
		exit(0);
	}
	n = -1;
	j = 0;
	char	revlabel = 0;
	while(!fp_edge.eof()) {
		std::getline(fp_edge, s);
		if(s.empty()) continue;
		const char* str = s.c_str();
/*
printf("str %s\n", str);
getchar();
*/
		if(str[0] == '>')	{
			if(n >= 0)	{
				edge[n].seq = (char *) smallapp::ckalloc(seqlen * sizeof(char));
				for(j = 0; j < seqlen; j ++)	{
					edge[n].seq[j] = tmpseq[j];
				}
				edge[n].length = seqlen;
				seqlen = 0;
			}
			replace(s.begin(), s.end(), ':', ' ');
			sscanf(&str[1], "%s%s", edgename, tmpstr);
			l = strlen(edgename);
			n ++;
			if(edgename[l - 1] == ';')	{
				edgename[l - 1] = '\0';
				l --;
			}
			j = FastGSPaDes::locateedge(alledgename, edgename, num_edge);
			edgeindex[j] = n;
			if(edgename[l - 1] != '\'')	{
				int revindex = FastGSPaDes::locaterevedge(alledgename, edgename, num_edge);
				if(revindex < 0)	{
					edge[n].bal_edge = n; // palindromic edge
				}
				edge[n].bal_edge = revindex;
				edge[revindex].bal_edge = n;
				revlabel = 0;
			} else	{
				revlabel = 1;
			}
/*
if(j == 241)	{
printf("str %s\n", str);
printf("edgename %s j %d n %d\n", edgename, j, n);
getchar();
}
j = 241;
printf("j %d edgeindex %d %d\n", j, edgeindex[2 * j], edgeindex[2 * j + 1]);
*/
		} else	{
			// get edge sequnece
			l = strlen(str);
			for(i = 0; i < l; i ++)	{
				if(str[i] >= 'a' && str[i] <= 'z')	{
					tmpseq[seqlen ++] = seq::char2int(str[i]);
				} else if(str[i] >= 'A' && str[i] <= 'Z')	{
					tmpseq[seqlen ++] = seq::char2int(str[i] - 'A' + 'a');
				}
			}
		}
	}
	if(seqlen > 0)	{
		edge[n].seq = (char *) smallapp::ckalloc(seqlen * sizeof(char));
		for(j = 0; j < seqlen; j ++)	{
			edge[n].seq[j] = tmpseq[j];
		}
		edge[n].length = seqlen;
		if(edge[n].length > max_len)	max_len = edge[n].length;
		n ++;
	}

	free((void *) tmpseq);
	fp_edge.close();
	if(n != num_edge)	{
		printf("Num-of-edges not equal: %d %d\n", n, num_edge);
		exit(0);
	}
	printf("%d edges input\n", n);

	int startedge, outedge, outvertex;
	num_vertex = 0;
	std::ifstream fp_edge2(edgeseqfile);
	if(!fp_edge2) {
		cout<<"cannot open file "<<edgeseqfile<<endl;
		exit(0);
	}
	n = j = 0;
	while(!fp_edge2.eof()) {
		std::getline(fp_edge2, s);
		if(s.empty()) continue;
		const char* str = s.c_str();
		if(str[0] == '>')	{
			replace(s.begin(), s.end(), ':', ' ');
			sscanf(&str[1], "%s%s", edgename, tmpstr);
			l = strlen(edgename);
			if(edgename[l - 1] == ';')	{
				tmpstr[0] = '\0';	// reset tmpstr if there is no outgoing edges
				edgename[l - 1] = '\0';
				l --;
			}
			j = FastGSPaDes::locateedge(alledgename, edgename, num_edge);
			startedge = edgeindex[j];
			outvertex = -1;
			l = strlen(tmpstr);
			k = 0;
			while(k < l)	{
				outedge = get_next_edge(tmpstr, &k, l, alledgename, num_edge);
				k ++;
				if(edge[outedge].nodeindex[0] >= 0)	{
					outvertex = edge[outedge].nodeindex[0];
					break;
				}
			}
			if(outvertex < 0)	{
				outvertex = num_vertex;
				vertex[num_vertex].lindex = str2code(&(edge[startedge].seq[edge[startedge].length - kmersize]), kmersize);
				num_vertex ++;
			}
			edge[startedge].nodeindex[1] = outvertex;
			vertex[outvertex].lastedge = soap::add_edge_to_vertex(&edge[startedge], vertex[outvertex].lastedge);
			vertex[outvertex].indegree ++;
			l = strlen(tmpstr);
			k = 0;
			while(k < l)	{
				outedge = get_next_edge(tmpstr, &k, l, alledgename, num_edge);
				k ++;
				if(edge[outedge].nodeindex[0] < 0)	{
					edge[outedge].nodeindex[0] = outvertex;
					vertex[outvertex].nextedge = soap::add_edge_to_vertex(&edge[outedge], vertex[outvertex].nextedge);
					vertex[outvertex].outdegree ++;
				}
			}
		}
	}
	fp_edge2.close();
	printf("num_vertex %d\n", num_vertex);

	std::ifstream fp_edge3(edgeseqfile);
	if(!fp_edge3) {
		cout<<"cannot open file "<<edgeseqfile<<endl;
		exit(0);
	}
	n = j = 0;
	while(!fp_edge3.eof()) {
		std::getline(fp_edge3, s);
		if(s.empty()) continue;
		const char* str = s.c_str();
		if(str[0] == '>')	{
			replace(s.begin(), s.end(), ':', ' ');
			sscanf(&str[1], "%s%s", edgename, tmpstr);
			sscanf(&edgename[5], "%d", &j);
			l = strlen(edgename);
			if(edgename[l - 1] == ';')	{
				tmpstr[0] = '\0';	// reset tmpstr if there is no outgoing edges
				edgename[l - 1] = '\0';
				l --;
			}
			j = FastGSPaDes::locateedge(alledgename, edgename, num_edge);
			startedge = edgeindex[j];
			if(edge[startedge].nodeindex[0] < 0)	{
				vertex[num_vertex].lindex = str2code(edge[startedge].seq, kmersize);
				edge[startedge].nodeindex[0] = num_vertex;
				vertex[num_vertex].nextedge = soap::add_edge_to_vertex(&edge[startedge], vertex[num_vertex].nextedge);
				vertex[num_vertex].outdegree ++;
				num_vertex ++;
			}
		}
	}
	fp_edge3.close();
	printf("num_vertex %d\n", num_vertex);

/*
	for(i = 0; i < num_vertex; i ++)	{
		if(vertex[i].outdegree == 0)	{
			printf("i %d degrees %d %d\n", i, vertex[i].indegree, vertex[i].outdegree);
			getchar();
		}
	}

for(i = 0; i < num_edge; i ++)	{
	printf("edge %d length %d start %d outdegree %d end %d indegree %d\n", i, edge[i].length, edge[i].nodeindex[0], vertex[edge[i].nodeindex[0]].outdegree,edge[i].nodeindex[1], vertex[edge[i].nodeindex[1]].indegree);
getchar();
}
*/

	return(num_vertex);
}

int FastGSPaDes::get_next_edge(char *tmpstr, int *start, int end, char **alledgename, int num_edge)
{
	int	i, j, k;
	char	temp[1000];

	i = *start;
	k = 0;
	for(; *start < end; (*start) ++)	{
		if(tmpstr[*start] == ',' || tmpstr[*start] == ';')	{
			break;
		}
		temp[k ++] = tmpstr[*start];
	}
	temp[k ++] = '\0';
	int index = FastGSPaDes::locateedge(alledgename, temp, num_edge);
	return(index);
}

uint256_t FastGSPaDes::str2code(char *seq, int kmersize)
{
	int	i, k, l;
	uint256_t	code;

	code.bits[0] = code.bits[1] = 0;
	k = 0;
	for(i = 0; i < kmersize; i ++)	{
		code.bits[k] *= 4;
		code.bits[k] += seq[i];
		if(i == 64)	{
			k ++;
		} 
	}
	return(code);
}
